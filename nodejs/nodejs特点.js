// nodejs 的特点：（实际上在官网里面首页就有）
// 事件驱动、非阻塞式 I/O 的模型，轻量又高效
// 就这三个特点：
// - 单线程
// - 非阻塞I/O模型
// - 事件驱动

// 首先重要理解nodejs的特点，一个一个理解

// 1. 单线程
// - 在java php net等服务器端语言中，会为每一个客户端连接一个新的线程，而每个线程需要耗费 2MB 的内存，也就是说，理论上一个8GB的
// 服务器能够同时连接的最大用户的数量为4000个左右，想要让web应用支持更多的用户，那么就要增加服务器的数量，因此web应用程序的硬件
// 成本就上去了
// - nodejs不为每一个客户连接创建一个新的线程，而是仅仅使用一个线程。当由用户连接了，就出发一个内部事件，通过非阻塞I/O，事件驱动机制
// 让nodejs宏观上也是并行的，使用nodejs，一个8GB内存的服务器，可以同时处理超过4万用户的连接

// 深刻理解多线程和单线程：
// - 一个完整的线程就是 客户端发出请求，然后服务器向数据库申请数据，简称I/O连接，但是在等待数据的这段时间内，进程被白白阻塞掉了
// 然后服务器拿到数据之后，在把数据返回给客户端，也就是说，在服务器等待数据的这一段时间里，进程被白白浪费掉了
// 1. 多线程
// - 多线程就是 当多个客户端 给服务器发送请求的时候，服务器会为每一个客户端创建一个线程，然后每一个线程都会出现 服务器在等待数据
// 时造成进程的极大浪费，这就是多线程弊端
// 2. 单线程
// - 单线程就是 当多个客户端向服务器发送请求的时候，服务器只会创建一个线程，而当遇到服务器等待数据的情况时，它不会等待，而是继续处理
// 下一个客户端的请求，当数据从数据库获取回来了，那么再把数据发送给客户端，进程的利用率100%
// 而且单线程会产生宏观“并发”的效果
// - 单线程的缺点也很明显：就是当一个用户造成了线程的崩溃，那么整个服务都崩溃了，其他用户也崩溃了

// 2. 非阻塞I/O
// - 传统的单线程机制中，当执行到访问数据库的代码时，整个线程将停止下来，等数据库把数据返回回来，才会执行后面的代码，也就是说I/O阻塞
// 了代码的执行，极大的降低了代码的执行效率
// - 当I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数，为了处理异步I/O，线程必须有事件循环，不断的
// 检查有没有未处理的事件，一次予以处理
// - 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量（执行效率）必须通过多线程。而在非阻塞模式下，一个线程永远在执行计算操作
// 这个线程的CPU核心利用率达到100%

// 3. 事件驱动
// - 在 nodejs 中，客户端请求建立连接，提交数据等行为，会触发相应的事件，在 node 中，一个时刻，只能执行一个事件的回调函数，但是在
// 执行事件的回调函数的中途，也可以处理其他事务（比如又有新的客户端请求连接），然后返回继续执行原事件的回调函数，这种机制，就是 事件循环
// 机制。
// - nodejs 底层的是c++，（V8也是c++写的） 底层代码中，近半数都是用于事件队列，回调函数队列的构建，用事件驱动来完成服务器的任务调度
// 这是天才才能想到的.
// - 针尖上的舞蹈,用一个线程,担负起了非常多的任务
// - 不管是新用户的请求,或者老用户的I/O完成了,都将以事件的方式加入事件环,等待调度


// 深刻理解nodejs的优点:
// - nodejs 善于I/O,就是事件的调度,任务的调度,不善于计算,为什么呢?因为是单线程,如果因为CPU过多的用于计算的话,那么在计算的这个时间里,其他用户
// 的请求就不能及时处理,只能等到计算完了才可以处理,某种意义上说,计算会阻塞这个单线程
// - 因此当应用程序需要处理大量并发的I/O的时候,并且应用程序内部不需要进行非常复杂的处理的时候,Nodejs非常合适
// - 如果业务有很多的CPU计算,那么nodejs不合适


// Nodejs没有根目录的概念,因为他没有web容器的概念
